<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mohack</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #f0f4ff 0%, #e6ecff 100%);
            color: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .bg {
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 15% 20%, rgba(100,200,120,0.12) 0%, transparent 40%),
                radial-gradient(circle at 85% 75%, rgba(80,180,255,0.10) 0%, transparent 50%);
            background-size: 180% 180%;
            animation: gradient 24s ease infinite;
            opacity: 0.7;
            z-index: 1;
        }
        
        @keyframes gradient {
            0%   { background-position: 0% 50%; }
            50%  { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .container {
            position: relative;
            z-index: 10;
            background: rgba(255,255,255,0.92);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(200,220,255,0.5);
            border-radius: 16px;
            padding: 2.8rem;
            width: 100%;
            max-width: 520px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.08), 0 8px 20px rgba(0,0,0,0.06);
            text-align: center;
            animation: slideIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes slideIn {
            0% {
                transform: translateY(50px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        h1 {
            font-size: 3.4rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: #0d47a1;
            letter-spacing: 5px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 2rem;
            font-size: 0.95rem;
            letter-spacing: 1px;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
            animation: fadeIn 0.5s ease-out backwards;
        }
        
        .form-group:nth-child(1) { animation-delay: 0.2s; }
        .form-group:nth-child(2) { animation-delay: 0.3s; }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        label {
            display: block;
            margin-bottom: 0.6rem;
            font-size: 0.95rem;
            font-weight: 600;
            color: #333;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input {
            width: 100%;
            padding: 14px 16px;
            font-size: 1.1rem;
            border-radius: 10px;
            border: 2px solid #d0e0ff;
            outline: none;
            transition: all 0.25s;
            background: #fafcff;
            color: #1a1a2e;
        }
        
        input:focus {
            border-color: #4caf50;
            box-shadow: 0 0 0 4px rgba(76,175,80,0.18);
        }
        
        input::placeholder {
            color: #999;
        }
        
        .btn-container {
            margin-top: 2.2rem;
        }
        
        button {
            width: 100%;
            padding: 16px;
            font-size: 1.1rem;
            border-radius: 10px;
            border: none;
            outline: none;
            transition: all 0.25s;
            background: #4caf50;
            color: white;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(76,175,80,0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        button:hover {
            background: #43a047;
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(76,175,80,0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #aaa;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Loading animation */
        .loader {
            display: none;
            margin: 30px auto;
            width: 80px;
            height: 80px;
            position: relative;
        }
        
        .loader.active {
            display: block;
        }
        
        .loader-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid transparent;
            border-top-color: #4caf50;
            border-radius: 50%;
            animation: spin 1.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
        }
        
        .loader-ring:nth-child(2) {
            border-top-color: #81c784;
            animation-delay: -0.5s;
        }
        
        .loader-ring:nth-child(3) {
            border-top-color: #a5d6a7;
            animation-delay: -1s;
        }
        
        @keyframes spin {
            0% {
                transform: rotate(0deg) scale(1);
            }
            50% {
                transform: rotate(180deg) scale(1.1);
            }
            100% {
                transform: rotate(360deg) scale(1);
            }
        }
        
        .loading-text {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 0.95rem;
            letter-spacing: 1px;
            display: none;
        }
        
        .loading-text.active {
            display: block;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 0.5;
            }
            50% {
                opacity: 1;
            }
        }
        
        .status-message {
            margin-top: 1.8rem;
            padding: 14px 18px;
            border-radius: 10px;
            font-size: 1.05rem;
            display: none;
            animation: slideDown 0.3s ease-out;
            text-align: center;
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .status-message.success {
            display: block;
            color: #2e7d32;
            background: rgba(232,245,233,0.9);
            border: 1px solid #a5d6a7;
        }
        
        .status-message.error {
            display: block;
            color: #c62828;
            background: rgba(254,235,236,0.9);
            border: 1px solid #ef9a9a;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 2rem 1.5rem;
            }
            
            h1 {
                font-size: 2.5rem;
                letter-spacing: 3px;
            }
        }
    </style>
</head>
<body>
    <div class="bg"></div>

    <div class="container">
        <p class="subtitle">getmo score submitter</p>

        <form id="scoreForm">
            <div class="form-group">
                <label for="playerName">Player Name</label>
                <input 
                    type="text" 
                    id="playerName" 
                    name="playerName" 
                    placeholder="Enter your name"
                    required
                >
            </div>

            <div class="form-group">
                <label for="targetScore">Target Score</label>
                <input 
                    type="number" 
                    id="targetScore" 
                    name="targetScore" 
                    placeholder="Enter desired score"
                    min="4"
                    step="4"
                    required
                >
            </div>

            <div class="btn-container">
                <button type="submit" id="submitBtn">
                    Generate & Submit
                </button>
            </div>
        </form>

        <div class="loader" id="loader">
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
        </div>

        <div class="loading-text" id="loadingText">Generating game data...</div>

        <div class="status-message" id="statusMessage"></div>
    </div>

    <script>
        // Game generation logic
        class Tile {
            constructor(position, value = 2) {
                this.x = position.x;
                this.y = position.y;
                this.value = value;
            }

            serialize() {
                return {
                    position: { x: this.x, y: this.y },
                    value: this.value
                };
            }
        }

        class Grid {
            constructor(size) {
                this.size = size;
                this.cells = this.empty();
            }

            empty() {
                const cells = [];
                for (let x = 0; x < this.size; x++) {
                    const row = [];
                    for (let y = 0; y < this.size; y++) {
                        row.push(null);
                    }
                    cells.push(row);
                }
                return cells;
            }

            insertTile(tile) {
                this.cells[tile.x][tile.y] = tile;
            }

            serialize() {
                const cellState = [];
                for (let x = 0; x < this.size; x++) {
                    const row = [];
                    for (let y = 0; y < this.size; y++) {
                        const tile = this.cells[x][y];
                        row.push(tile ? tile.serialize() : null);
                    }
                    cellState.push(row);
                }
                return {
                    size: this.size,
                    cells: cellState
                };
            }
        }

        class ValidMergeSequenceBuilder {
            constructor(targetScore) {
                this.targetScore = targetScore;
                this.tileInventory = {};
                this.mergeSequence = [];
                this.spawnSequence = [];
            }

            buildMergeSequence() {
                let currentScore = 0;
                
                // Start with 2 initial tiles
                this.spawnTile(2);
                this.spawnTile(2);
                
                // Spawn initial tiles
                const initialSpawns = Math.min(100, Math.floor(this.targetScore / 10));
                for (let i = 0; i < initialSpawns; i++) {
                    const spawnValue = Math.random() < 0.9 ? 2 : 4;
                    this.spawnTile(spawnValue);
                }
                
                let attempts = 0;
                while (currentScore < this.targetScore && attempts < 100000) {
                    attempts++;
                    
                    let mergeMade = false;
                    for (let power = 2; power <= 16; power++) {
                        const value = Math.pow(2, power);
                        const halfValue = value / 2;
                        
                        if ((this.tileInventory[halfValue] || 0) >= 2) {
                            if (currentScore + value <= this.targetScore + 100) {
                                this.makeMerge(halfValue);
                                currentScore += value;
                                mergeMade = true;
                            }
                        }
                    }
                    
                    if (!mergeMade || Math.random() < 0.7) {
                        const spawnValue = Math.random() < 0.9 ? 2 : 4;
                        this.spawnTile(spawnValue);
                    }
                }
                
                const actualScore = this.mergeSequence.reduce((a, b) => a + b, 0);
                return {
                    mergeSequence: this.mergeSequence,
                    actualScore: actualScore,
                    spawnCount: this.spawnSequence.length
                };
            }

            spawnTile(value) {
                this.spawnSequence.push(value);
                this.tileInventory[value] = (this.tileInventory[value] || 0) + 1;
            }

            makeMerge(halfValue) {
                const fullValue = halfValue * 2;
                this.tileInventory[halfValue] -= 2;
                if (this.tileInventory[halfValue] === 0) {
                    delete this.tileInventory[halfValue];
                }
                this.tileInventory[fullValue] = (this.tileInventory[fullValue] || 0) + 1;
                this.mergeSequence.push(fullValue);
            }
        }

        class FirebaseSubmitter {
            constructor() {
                this.apiKey = "AIzaSyBEUEKrOEBm3RjxIPdk25zNfkqZHYXMCWA";
                this.databaseUrl = "https://getmo-79b09-default-rtdb.firebaseio.com";
                this.authUrl = "https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=";
                this.idToken = null;
                this.uid = null;
            }

            async authenticate() {
                console.log('üîê Authenticating with Firebase...');
                
                const url = `${this.authUrl}${this.apiKey}`;
                const payload = {
                    returnSecureToken: true
                };
                
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    const data = await response.json();
                    this.idToken = data.idToken;
                    this.uid = data.localId;
                    
                    console.log('‚úÖ Authenticated successfully!');
                    console.log(`   UID: ${this.uid.substring(0, 10)}...`);
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Authentication failed:', error);
                    return false;
                }
            }

            generateGameData(targetScore) {
                console.log(`üéÆ Generating game data for score: ${targetScore}`);
                
                // Build merge sequence
                const builder = new ValidMergeSequenceBuilder(targetScore);
                const result = builder.buildMergeSequence();
                const scoreStamps = result.mergeSequence;
                const actualScore = result.actualScore;
                const spawnCount = result.spawnCount;
                
                console.log(`   Merges: ${scoreStamps.length}`);
                console.log(`   Actual score: ${actualScore}`);
                console.log(`   Spawns: ${spawnCount}`);
                
                // Calculate turns
                const turnCount = Math.max(spawnCount - 2, 1);
                
                // Generate timestamps
                const gameDurationMinutes = (turnCount * (Math.random() * 3 + 2)) / 60;
                const gameStart = new Date(Date.now() - gameDurationMinutes * 60 * 1000);
                const timeStamps = [gameStart];
                
                let currentTime = new Date(gameStart);
                for (let i = 0; i < turnCount; i++) {
                    const interval = Math.random() < 0.1 
                        ? Math.random() * 10 + 5 
                        : Math.random() * 4 + 1;
                    currentTime = new Date(currentTime.getTime() + interval * 1000);
                    timeStamps.push(currentTime);
                }
                
                // Generate grids
                const grids = [];
                for (let moveNum = 0; moveNum < turnCount; moveNum++) {
                    const grid = new Grid(4);
                    const progress = moveNum / turnCount;
                    
                    let tileValues;
                    if (progress < 0.2) {
                        tileValues = [2, 2, 4, 4, 2, 4, 8, 2, 2, 4, 2, 2, 4, 2, 2, 2];
                    } else if (progress < 0.5) {
                        tileValues = [2, 4, 8, 16, 32, 8, 16, 4, 8, 16, 4, 2, 8, 4, 2, 2];
                    } else if (progress < 0.8) {
                        tileValues = [16, 32, 64, 128, 256, 32, 64, 128, 16, 32, 64, 8, 16, 8, 4, 2];
                    } else {
                        tileValues = [256, 512, 1024, 2048, 128, 256, 512, 64, 128, 32, 64, 16, 32, 8, 4, 2];
                    }
                    
                    const allPositions = [];
                    for (let x = 0; x < 4; x++) {
                        for (let y = 0; y < 4; y++) {
                            allPositions.push({x, y});
                        }
                    }
                    
                    // Shuffle
                    for (let i = allPositions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
                    }
                    
                    for (let i = 0; i < 16; i++) {
                        const tile = new Tile(allPositions[i], tileValues[i % tileValues.length]);
                        grid.insertTile(tile);
                    }
                    
                    grids.push(grid.serialize());
                }
                
                // Generate final grid
                const biggestTile = scoreStamps.length > 0 ? Math.max(...scoreStamps) : 2;
                const biggestTileCount = scoreStamps.filter(s => s === biggestTile).length;
                
                const finalGrid = new Grid(4);
                const tileValues = [];
                
                for (let i = 0; i < biggestTileCount; i++) {
                    tileValues.push(biggestTile);
                }
                
                let currentValue = biggestTile / 2;
                let remaining = 16 - biggestTileCount;
                
                while (remaining > 0 && currentValue >= 2) {
                    const numTiles = Math.min(Math.floor(Math.random() * 3) + 1, remaining);
                    for (let i = 0; i < numTiles; i++) {
                        tileValues.push(currentValue);
                    }
                    remaining -= numTiles;
                    currentValue /= 2;
                }
                
                while (tileValues.length < 16) {
                    tileValues.push(2);
                }
                
                const allPositions = [];
                for (let x = 0; x < 4; x++) {
                    for (let y = 0; y < 4; y++) {
                        allPositions.push({x, y});
                    }
                }
                
                // Shuffle
                for (let i = allPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
                }
                
                for (let i = 0; i < 16; i++) {
                    const tile = new Tile(allPositions[i], tileValues[i]);
                    finalGrid.insertTile(tile);
                }
                
                return {
                    score: actualScore,
                    turns: turnCount,
                    gameStart: gameStart,
                    grid: finalGrid,
                    grids: grids,
                    timeStamps: timeStamps,
                    scoreStamps: scoreStamps
                };
            }

            async submitScore(name, gameData) {
                if (!this.idToken) {
                    console.error('‚ùå Not authenticated!');
                    return false;
                }
                
                console.log(`üì§ Submitting score for '${name}'...`);
                
                const timestamp = Date.now();
                const gameStartTimestamp = gameData.gameStart.getTime();
                
                const scoreData = {
                    name: name,
                    score: gameData.score,
                    turns: gameData.turns,
                    timestamp: timestamp,
                    gameStart: gameStartTimestamp,
                    uid: this.uid,
                    validation: {
                        biggestTile: gameData.scoreStamps.length > 0 ? Math.max(...gameData.scoreStamps) : 2,
                        totalMerges: gameData.scoreStamps.length,
                        gameDuration: timestamp - gameStartTimestamp
                    }
                };
                
                try {
                    const url = `${this.databaseUrl}/scores.json?auth=${this.idToken}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(scoreData)
                    });
                    
                    const result = await response.json();
                    
                    console.log('‚úÖ Score submitted successfully!');
                    console.log(`   Firebase key: ${result.name}`);
                    console.log(`   Score: ${gameData.score}`);
                    console.log(`   Turns: ${gameData.turns}`);
                    
                    // Also record in userSubmissions
                    const userSubmission = {
                        timestamp: timestamp,
                        score: gameData.score
                    };
                    
                    const userUrl = `${this.databaseUrl}/userSubmissions/${this.uid}.json?auth=${this.idToken}`;
                    await fetch(userUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(userSubmission)
                    });
                    
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Submission failed:', error);
                    return false;
                }
            }
        }

        // Form submission handler
        document.getElementById('scoreForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const playerName = document.getElementById('playerName').value;
            const targetScore = parseInt(document.getElementById('targetScore').value);
            const submitBtn = document.getElementById('submitBtn');
            const loader = document.getElementById('loader');
            const loadingText = document.getElementById('loadingText');
            const statusMessage = document.getElementById('statusMessage');

            // Reset status
            statusMessage.className = 'status-message';
            statusMessage.textContent = '';

            // Show loading
            submitBtn.disabled = true;
            loader.classList.add('active');
            loadingText.classList.add('active');

            try {
                // Initialize Firebase submitter
                const submitter = new FirebaseSubmitter();
                
                // Authenticate
                const authenticated = await submitter.authenticate();
                if (!authenticated) {
                    throw new Error('Authentication failed');
                }
                
                // Generate game data
                const gameData = submitter.generateGameData(targetScore);
                
                // Submit to Firebase
                const success = await submitter.submitScore(playerName, gameData);
                
                if (success) {
                    statusMessage.className = 'status-message success';
                    statusMessage.textContent = `‚úÖ Score submitted successfully! Score: ${gameData.score}, Turns: ${gameData.turns}, Merges: ${gameData.scoreStamps.length}`;
                    
                    // Reset form
                    document.getElementById('scoreForm').reset();
                } else {
                    throw new Error('Submission to Firebase failed');
                }

            } catch (error) {
                statusMessage.className = 'status-message error';
                statusMessage.textContent = `‚ùå Error: ${error.message}`;
                console.error(error);
            } finally {
                submitBtn.disabled = false;
                loader.classList.remove('active');
                loadingText.classList.remove('active');
            }
        });
    </script>
</body>
</html>
