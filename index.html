<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>getmo hack</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #f0f4ff 0%, #e6ecff 100%);
            color: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .bg {
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 15% 20%, rgba(100,200,120,0.12) 0%, transparent 40%),
                radial-gradient(circle at 85% 75%, rgba(80,180,255,0.10) 0%, transparent 50%);
            background-size: 180% 180%;
            animation: gradient 24s ease infinite;
            opacity: 0.7;
            z-index: 1;
        }
        
        @keyframes gradient {
            0%   { background-position: 0% 50%; }
            50%  { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .container {
            position: relative;
            z-index: 10;
            background: rgba(255,255,255,0.92);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(200,220,255,0.5);
            border-radius: 16px;
            padding: 2.8rem;
            width: 100%;
            max-width: 520px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.08), 0 8px 20px rgba(0,0,0,0.06);
            text-align: center;
            animation: slideIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes slideIn {
            0% {
                transform: translateY(50px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        h1 {
            font-size: 3.4rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: #0d47a1;
            letter-spacing: 5px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 2rem;
            font-size: 0.95rem;
            letter-spacing: 1px;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
            animation: fadeIn 0.5s ease-out backwards;
        }
        
        .form-group:nth-child(1) { animation-delay: 0.2s; }
        .form-group:nth-child(2) { animation-delay: 0.3s; }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        label {
            display: block;
            margin-bottom: 0.6rem;
            font-size: 0.95rem;
            font-weight: 600;
            color: #333;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input {
            width: 100%;
            padding: 14px 16px;
            font-size: 1.1rem;
            border-radius: 10px;
            border: 2px solid #d0e0ff;
            outline: none;
            transition: all 0.25s;
            background: #fafcff;
            color: #1a1a2e;
        }
        
        input:focus {
            border-color: #4caf50;
            box-shadow: 0 0 0 4px rgba(76,175,80,0.18);
        }
        
        input::placeholder {
            color: #999;
        }
        
        .btn-container {
            margin-top: 2.2rem;
        }
        
        button {
            width: 100%;
            padding: 16px;
            font-size: 1.1rem;
            border-radius: 10px;
            border: none;
            outline: none;
            transition: all 0.25s;
            background: #4caf50;
            color: white;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(76,175,80,0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        button:hover {
            background: #43a047;
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(76,175,80,0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #aaa;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Loading animation */
        .loader {
            display: none;
            margin: 30px auto;
            width: 80px;
            height: 80px;
            position: relative;
        }
        
        .loader.active {
            display: block;
        }
        
        .loader-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid transparent;
            border-top-color: #4caf50;
            border-radius: 50%;
            animation: spin 1.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
        }
        
        .loader-ring:nth-child(2) {
            border-top-color: #81c784;
            animation-delay: -0.5s;
        }
        
        .loader-ring:nth-child(3) {
            border-top-color: #a5d6a7;
            animation-delay: -1s;
        }
        
        @keyframes spin {
            0% {
                transform: rotate(0deg) scale(1);
            }
            50% {
                transform: rotate(180deg) scale(1.1);
            }
            100% {
                transform: rotate(360deg) scale(1);
            }
        }
        
        .loading-text {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 0.95rem;
            letter-spacing: 1px;
            display: none;
        }
        
        .loading-text.active {
            display: block;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 0.5;
            }
            50% {
                opacity: 1;
            }
        }
        
        .status-message {
            margin-top: 1.8rem;
            padding: 14px 18px;
            border-radius: 10px;
            font-size: 1.05rem;
            display: none;
            animation: slideDown 0.3s ease-out;
            text-align: center;
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .status-message.success {
            display: block;
            color: #2e7d32;
            background: rgba(232,245,233,0.9);
            border: 1px solid #a5d6a7;
        }
        
        .status-message.error {
            display: block;
            color: #c62828;
            background: rgba(254,235,236,0.9);
            border: 1px solid #ef9a9a;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 2rem 1.5rem;
            }
            
            h1 {
                font-size: 2.5rem;
                letter-spacing: 3px;
            }
        }
    </style>
</head>
<body>
    <div class="bg"></div>

    <div class="container">
        
        <p class="subtitle">getmo score submitter</p>

        <form id="scoreForm">
            <div class="form-group">
                <label for="playerName">Player Name</label>
                <input 
                    type="text" 
                    id="playerName" 
                    name="playerName" 
                    placeholder="Enter your name"
                    required
                >
            </div>

            <div class="form-group">
                <label for="targetScore">Target Score</label>
                <input 
                    type="number" 
                    id="targetScore" 
                    name="targetScore" 
                    placeholder="Enter desired score"
                    min="4"
                    step="4"
                    required
                >
            </div>

            <div class="btn-container">
                <button type="submit" id="submitBtn">
                    Generate & Submit
                </button>
            </div>
        </form>

        <div class="loader" id="loader">
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
        </div>

        <div class="loading-text" id="loadingText">Generating game data...</div>

        <div class="status-message" id="statusMessage"></div>
    </div>

    <script>
        // Game generation logic converted from Python
        class Tile {
            constructor(position, value = 2) {
                this.x = position.x;
                this.y = position.y;
                this.value = value;
            }

            serialize() {
                return {
                    position: { x: this.x, y: this.y },
                    value: this.value
                };
            }
        }

        class Grid {
            constructor(size, previousState = null) {
                this.size = size;
                this.cells = previousState ? this.fromState(previousState) : this.empty();
            }

            empty() {
                const cells = [];
                for (let x = 0; x < this.size; x++) {
                    const row = [];
                    for (let y = 0; y < this.size; y++) {
                        row.push(null);
                    }
                    cells.push(row);
                }
                return cells;
            }

            fromState(state) {
                const cells = [];
                for (let x = 0; x < this.size; x++) {
                    const row = [];
                    for (let y = 0; y < this.size; y++) {
                        const tileData = state[x][y];
                        const tile = tileData ? new Tile(tileData.position, tileData.value) : null;
                        row.push(tile);
                    }
                    cells.push(row);
                }
                return cells;
            }

            insertTile(tile) {
                this.cells[tile.x][tile.y] = tile;
            }

            serialize() {
                const cellState = [];
                for (let x = 0; x < this.size; x++) {
                    const row = [];
                    for (let y = 0; y < this.size; y++) {
                        const tile = this.cells[x][y];
                        row.push(tile ? tile.serialize() : null);
                    }
                    cellState.push(row);
                }
                return {
                    size: this.size,
                    cells: cellState
                };
            }
        }

        class ValidMergeSequenceBuilder {
            constructor(targetScore) {
                this.targetScore = targetScore;
                this.tileInventory = {};
                this.mergeSequence = [];
                this.spawnSequence = [];
            }

            buildMergeSequence() {
                let currentScore = 0;
                
                // Start with 2 initial tiles (both 2s)
                this.spawnTile(2);
                this.spawnTile(2);
                
                let attempts = 0;
                const maxAttempts = 100000;
                
                while (currentScore < this.targetScore && attempts < maxAttempts) {
                    attempts++;
                    
                    let mergeMade = false;
                    
                    // Try merging from largest to smallest
                    for (let power = 16; power >= 2; power--) {
                        const value = Math.pow(2, power);
                        const halfValue = value / 2;
                        
                        // Can we make this merge?
                        if ((this.tileInventory[halfValue] || 0) >= 2) {
                            // Check if this merge would fit in our target
                            if (currentScore + value <= this.targetScore + 1000) {
                                // Make the merge!
                                this.makeMerge(halfValue);
                                currentScore += value;
                                mergeMade = true;
                                break;
                            }
                        }
                    }
                    
                    // If no merge was possible or beneficial, spawn a new tile
                    if (!mergeMade || Math.random() < 0.3) {
                        // Spawn a tile (90% chance of 2, 10% chance of 4)
                        const spawnValue = Math.random() < 0.9 ? 2 : 4;
                        this.spawnTile(spawnValue);
                    }
                }
                
                const actualScore = this.mergeSequence.reduce((a, b) => a + b, 0);
                return {
                    mergeSequence: this.mergeSequence,
                    actualScore: actualScore,
                    spawnCount: this.spawnSequence.length
                };
            }

            spawnTile(value) {
                this.spawnSequence.push(value);
                this.tileInventory[value] = (this.tileInventory[value] || 0) + 1;
            }

            makeMerge(halfValue) {
                const fullValue = halfValue * 2;
                
                // Remove two tiles of halfValue
                this.tileInventory[halfValue] -= 2;
                if (this.tileInventory[halfValue] === 0) {
                    delete this.tileInventory[halfValue];
                }
                
                // Add one tile of fullValue
                this.tileInventory[fullValue] = (this.tileInventory[fullValue] || 0) + 1;
                
                // Record the merge
                this.mergeSequence.push(fullValue);
            }
        }

        class TheoreticalGameGenerator {
            constructor(targetScore, size = 4) {
                this.targetScore = targetScore;
                this.size = size;
                this.grid = new Grid(size);
                this.score = 0;
                this.turnCount = 0;
                this.spawnCount = 0;
            }

            generateValidScoreStamps() {
                const builder = new ValidMergeSequenceBuilder(this.targetScore);
                const result = builder.buildMergeSequence();
                
                this.spawnCount = result.spawnCount;
                
                return {
                    mergeSequence: result.mergeSequence,
                    actualScore: result.actualScore
                };
            }

            generateRealisticGridProgression(numMoves) {
                const grids = [];
                
                let grid = new Grid(this.size);
                const positions = [{x: 0, y: 0}, {x: 0, y: 1}];
                positions.forEach(pos => {
                    const tile = new Tile(pos, 2);
                    grid.insertTile(tile);
                });
                grids.push(JSON.parse(JSON.stringify(grid.serialize())));

                for (let moveNum = 1; moveNum < numMoves; moveNum++) {
                    grid = new Grid(this.size);
                    const progress = moveNum / numMoves;
                    
                    let numTiles, tileValues;
                    if (progress < 0.2) {
                        numTiles = Math.min(moveNum + 2, 8);
                        tileValues = [2, 2, 4, 4, 2, 4, 8, 8].slice(0, numTiles);
                    } else if (progress < 0.5) {
                        numTiles = Math.floor(Math.random() * 5) + 6;
                        tileValues = [2, 4, 8, 16, 32, 8, 16, 4, 8, 16].slice(0, numTiles);
                    } else if (progress < 0.8) {
                        numTiles = Math.floor(Math.random() * 5) + 8;
                        tileValues = [16, 32, 64, 128, 256, 32, 64, 128, 16, 32, 64, 8].slice(0, numTiles);
                    } else {
                        numTiles = Math.floor(Math.random() * 6) + 10;
                        tileValues = [256, 512, 1024, 2048, 128, 256, 512, 64, 128, 32, 64, 16, 32, 8, 4].slice(0, numTiles);
                    }

                    const availablePositions = [];
                    for (let x = 0; x < this.size; x++) {
                        for (let y = 0; y < this.size; y++) {
                            availablePositions.push({x, y});
                        }
                    }
                    
                    // Shuffle
                    for (let i = availablePositions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
                    }

                    for (let i = 0; i < tileValues.length && i < availablePositions.length; i++) {
                        const tile = new Tile(availablePositions[i], tileValues[i]);
                        grid.insertTile(tile);
                    }

                    grids.push(JSON.parse(JSON.stringify(grid.serialize())));
                }

                return grids;
            }

            generateFinalGrid(score) {
                const grid = new Grid(this.size);
                
                let tileValues;
                if (score < 1000) {
                    tileValues = [128, 64, 32, 16, 8, 4, 2, 2, 4, 8];
                } else if (score < 5000) {
                    tileValues = [512, 256, 128, 64, 32, 16, 8, 4, 4, 2, 2];
                } else if (score < 10000) {
                    tileValues = [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2];
                } else if (score < 20000) {
                    tileValues = [2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4];
                } else if (score < 50000) {
                    tileValues = [4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2];
                } else {
                    tileValues = [8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4];
                }

                const availablePositions = [];
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.size; y++) {
                        availablePositions.push({x, y});
                    }
                }
                
                // Shuffle
                for (let i = availablePositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
                }

                const numTiles = Math.floor(Math.random() * 3) + 14;
                for (let i = 0; i < Math.min(numTiles, tileValues.length, availablePositions.length); i++) {
                    const tile = new Tile(availablePositions[i], tileValues[i]);
                    grid.insertTile(tile);
                }

                return grid;
            }

            generateTimeStamps(numMoves, gameDurationMinutes = null) {
                if (!gameDurationMinutes) {
                    gameDurationMinutes = (numMoves * (Math.random() * 3 + 2)) / 60;
                }

                const startTime = new Date(Date.now() - gameDurationMinutes * 60 * 1000);
                const timeStamps = [startTime];
                
                let currentTime = new Date(startTime);
                for (let i = 0; i < numMoves; i++) {
                    const interval = Math.random() < 0.1 
                        ? Math.random() * 10 + 5 
                        : Math.random() * 4 + 1;
                    
                    currentTime = new Date(currentTime.getTime() + interval * 1000);
                    timeStamps.push(currentTime);
                }

                return timeStamps;
            }

            estimateMovesFromSpawns(spawnCount) {
                // In 2048, you spawn one tile per move (after the initial 2)
                // So moves = spawns - 2 (for the initial tiles)
                return Math.max(spawnCount - 2, 1);
            }

            generateGameData() {
                console.log('üéØ Generating theoretical game data for score:', this.targetScore);
                
                // Generate VALID score stamps using new algorithm
                const result = this.generateValidScoreStamps();
                const scoreStamps = result.mergeSequence;
                const actualScore = result.actualScore;
                this.score = actualScore;

                console.log('‚úì Generated', scoreStamps.length, 'merges');
                console.log('‚úì Actual score from merges:', actualScore);
                console.log('‚úì Total spawns:', this.spawnCount);

                // Calculate number of moves from spawns
                this.turnCount = this.estimateMovesFromSpawns(this.spawnCount);
                console.log('‚úì Calculated moves:', this.turnCount);

                const grids = this.generateRealisticGridProgression(this.turnCount);
                console.log('‚úì Generated', grids.length, 'grid states');

                this.grid = this.generateFinalGrid(actualScore);
                console.log('‚úì Generated final grid');
                
                const timeStamps = this.generateTimeStamps(this.turnCount);
                const gameStart = timeStamps[0];
                console.log('‚úì Generated', timeStamps.length, 'timestamps');

                return {
                    score: this.score,
                    turns: this.turnCount,
                    gameStart: gameStart.toISOString(),
                    grid: this.grid.serialize(),
                    grids: grids,
                    timeStamps: timeStamps.map(ts => ts.toISOString()),
                    scoreStamps: scoreStamps
                };
            }
        }

        // Form submission handler
        document.getElementById('scoreForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const playerName = document.getElementById('playerName').value;
            const targetScore = parseInt(document.getElementById('targetScore').value);
            const submitBtn = document.getElementById('submitBtn');
            const loader = document.getElementById('loader');
            const loadingText = document.getElementById('loadingText');
            const statusMessage = document.getElementById('statusMessage');

            // Reset status
            statusMessage.className = 'status-message';
            statusMessage.textContent = '';

            // Show loading
            submitBtn.disabled = true;
            loader.classList.add('active');
            loadingText.classList.add('active');

            try {
                // Generate game data
                const generator = new TheoreticalGameGenerator(targetScore);
                const gameData = generator.generateGameData();

                // Prepare submission
                const payload = {
                    name: playerName,
                    ...gameData
                };

                // Submit to server
                const scriptUrl = 'https://script.google.com/macros/s/AKfycbw5MCKtkyy5iWIKQbx6AyYy7Gno4HTZjOraOmDVW00lD7AkkAcTSGdfk5F4bRuNndgJ/exec';
                
                const response = await fetch(scriptUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                    mode: 'no-cors'
                });

                // Show success
                statusMessage.className = 'status-message success';
                statusMessage.textContent = `‚úÖ Score submitted successfully! Generated ${gameData.turns} moves with ${gameData.scoreStamps.length} merges.`;

                // Reset form
                document.getElementById('scoreForm').reset();

            } catch (error) {
                // Show error
                statusMessage.className = 'status-message error';
                statusMessage.textContent = `‚ùå Error: ${error.message}`;
            } finally {
                // Hide loading
                submitBtn.disabled = false;
                loader.classList.remove('active');
                loadingText.classList.remove('active');
            }
        });
    </script>
</body>
</html>
